// src/visuals/axe-gradue/axe-gradue.js

class AxeGradueComponent extends HTMLElement {
  constructor() {
    super();
    this.config = { 
      min: 0, max: 10, step: 1, 
      orientation: 'horizontal', 
      width: 800, height: 80, 
      points: [], showNumbers: true,
      labelFrequency: 1,
      visibleLabels: null 
    };
    this.hitRegions = [];
    this.hoveredPoint = null;
  }

  connectedCallback() {
    this.render();
  }

  // ðŸ› ï¸ UTILITAIRE : PrÃ©cision mathÃ©matique pour Ã©viter le bug "0,700000001"
  round(v, s) {
    const p = (s.toString().split('.')[1] || '').length;
    return parseFloat(v.toFixed(p));
  }

  // ðŸ› ï¸ UTILITAIRE : Adapter dimensions selon orientation
  adjustDimensionsForOrientation() {
    if (this.config.orientation === 'vertical') {
      // Si dimensions par dÃ©faut horizontal (450x100), adapter pour vertical
      // SEULEMENT si width/height n'ont pas Ã©tÃ© explicitement dÃ©finis dans la config
      if (this.config.width === 800 && this.config.height === 80) {
        this.config.width = 140;
        this.config.height = 160;
      }
    }
  }

  // ðŸ› ï¸ UTILITAIRE : Marge interne unifiÃ©e (rÃ©duite pour gagner de la place)
  getPadding() {
    return 15;
  }

  // ðŸ› ï¸ UTILITAIRE : Dessiner une flÃ¨che propre au bout de l'axe
  drawArrow(ctx, x1, y1, x2, y2) {
    const size = 10;
    const angle = Math.atan2(y2 - y1, x2 - x1);
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - size * Math.cos(angle - Math.PI / 6), y2 - size * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(x2 - size * Math.cos(angle + Math.PI / 6), y2 - size * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fill();
  }

  render() {
    this.parseAttributes();
    this.adjustDimensionsForOrientation();
    this.innerHTML = '';
    const canvas = document.createElement('canvas');
    this.canvas = canvas;
    const ctx = canvas.getContext('2d');

    // Support Haute DÃ©finition (Retina)
    canvas.width = this.config.width * 2;
    canvas.height = this.config.height * 2;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.maxWidth = this.config.width + 'px';
    canvas.style.maxHeight = this.config.height + 'px';
    canvas.style.objectFit = 'contain';
    ctx.scale(2, 2);
    this.appendChild(canvas);

    // RÃ©cupÃ©ration dynamique de la couleur du thÃ¨me
    const style = getComputedStyle(document.documentElement);
    this.primaryColor = style.getPropertyValue('--color-guide-primary').trim() || '#0d9488';
    this.ctx = ctx;

    // Gestion des Ã©vÃ©nements souris
    canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
    canvas.addEventListener('mouseleave', this.handleMouseLeave.bind(this));

    this.draw();
  }

  handleMouseMove(e) {
    const rect = this.canvas.getBoundingClientRect();
    // Calcul de l'Ã©chelle entre les pixels CSS et le systÃ¨me de coordonnÃ©es interne
    const scaleX = this.config.width / rect.width;
    const scaleY = this.config.height / rect.height;

    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;

    // DÃ©tection de collision (cercle de rayon 10px pour faciliter le survol)
    const hit = this.hitRegions.find(p => {
      const dx = x - p.x;
      const dy = y - p.y;
      return dx * dx + dy * dy <= 100; // 10^2
    });

    if (hit !== this.hoveredPoint) {
      this.hoveredPoint = hit;
      this.canvas.style.cursor = hit ? 'pointer' : 'default';
      this.draw();
    }
  }

  handleMouseLeave() {
    if (this.hoveredPoint) {
      this.hoveredPoint = null;
      this.draw();
    }
  }

  draw() {
    const { ctx, config } = this;
    // Effacer le canvas
    ctx.clearRect(0, 0, config.width, config.height);

    if (config.orientation === 'horizontal') {
      this.drawHorizontalAxis();
    } else {
      this.drawVerticalAxis();
    }

    this.drawPoints();
    this.drawTooltip();
  }

  drawHorizontalAxis() {
    const { ctx } = this;
    const { min, max, step, width, height, showNumbers, labelFrequency, visibleLabels } = this.config;
    const padding = this.getPadding();
    const range = max - min;
    const axisLen = width - padding * 2;
    const y = height / 2;

    // Calcul densitÃ© des Ã©tiquettes (pas moins de 40px d'Ã©cart)
    const pxPerStep = (step / range) * axisLen;
    const labelFreq = pxPerStep < 40 ? Math.ceil(40 / pxPerStep) : 1;
    const finalFreq = Math.max(labelFrequency || 1, labelFreq);

    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 2;

    // Ligne et FlÃ¨che
    ctx.beginPath();
    ctx.moveTo(padding, y);
    ctx.lineTo(width - padding, y);
    ctx.stroke();
    this.drawArrow(ctx, width - padding - 10, y, width - padding, y);

    // Graduations
    for (let v = min, i = 0; v <= max + (step/2); v += step, i++) {
      const val = this.round(v, step);
      const x = padding + ((val - min) / range) * axisLen;
      
      let isMajor = false;
      if (visibleLabels && Array.isArray(visibleLabels) && visibleLabels.length > 0) {
        isMajor = visibleLabels.includes(val);
      } else {
        isMajor = i % finalFreq === 0;
      }

      ctx.beginPath();
      ctx.moveTo(x, y - (isMajor ? 8 : 4));
      ctx.lineTo(x, y + (isMajor ? 8 : 4));
      ctx.stroke();

      if (showNumbers && isMajor) {
        ctx.fillStyle = '#1e293b';
        ctx.textAlign = 'center';
        ctx.font = 'bold 12px Lexend Deca, sans-serif';
        ctx.fillText(val.toString().replace('.', ','), x, y + 25);
      }
    }
  }

  drawVerticalAxis() {
    const { ctx } = this;
    const { min, max, step, width, height, showNumbers, labelFrequency, visibleLabels } = this.config;
    const padding = this.getPadding();
    const range = max - min;
    const axisLen = height - padding * 2;
    const x = width / 2;

    const pxPerStep = (step / range) * axisLen;
    const labelFreq = pxPerStep < 40 ? Math.ceil(40 / pxPerStep) : 1;
    const finalFreq = Math.max(labelFrequency || 1, labelFreq);

    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 2;

    // Ligne et FlÃ¨che (vers le haut)
    ctx.beginPath();
    ctx.moveTo(x, height - padding);
    ctx.lineTo(x, padding);
    ctx.stroke();
    this.drawArrow(ctx, x, padding + 15, x, padding);

    // Graduations
    for (let v = min, i = 0; v <= max + (step/2); v += step, i++) {
      const val = this.round(v, step);
      const y = (height - padding) - ((val - min) / range) * axisLen;
      
      let isMajor = false;
      if (visibleLabels && Array.isArray(visibleLabels) && visibleLabels.length > 0) {
        isMajor = visibleLabels.includes(val);
      } else {
        isMajor = i % finalFreq === 0;
      }

      ctx.beginPath();
      ctx.moveTo(x - (isMajor ? 8 : 4), y);
      ctx.lineTo(x + (isMajor ? 8 : 4), y);
      ctx.stroke();

      if (showNumbers && isMajor) {
        ctx.fillStyle = '#1e293b';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.font = 'bold 14px Lexend Deca, sans-serif';
        const labelX = x - 20;
        ctx.fillText(val.toString().replace('.', ','), labelX, y);
      }
    }
  }

  drawPoints() {
    const { ctx } = this;
    const { min, max, orientation, width, height, points } = this.config;
    const padding = this.getPadding();
    const range = max - min;
    const axisLen = (orientation === 'horizontal' ? width : height) - padding * 2;
    this.hitRegions = [];

    points.forEach(p => {
      const ratio = (p.value - min) / range;
      ctx.fillStyle = p.color || this.primaryColor;
      
      const px = orientation === 'horizontal' ? padding + ratio * axisLen : width / 2;
      const py = orientation === 'horizontal' ? height / 2 : (height - padding) - ratio * axisLen;

      ctx.beginPath();
      ctx.arc(px, py, 6, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.font = 'bold 14px Lexend Deca, sans-serif';
      ctx.textAlign = orientation === 'horizontal' ? 'center' : 'left';
      ctx.fillText(p.label, px + (orientation === 'horizontal' ? 0 : 12), py - (orientation === 'horizontal' ? 15 : 0));
      
      // Enregistrer la zone de collision
      this.hitRegions.push({ x: px, y: py, value: p.value, label: p.label });
    });
  }

  drawTooltip() {
    if (!this.hoveredPoint) return;
    const { ctx } = this;
    const p = this.hoveredPoint;
    const text = `${p.value}`;

    ctx.save();
    ctx.font = 'bold 12px Lexend Deca, sans-serif';
    const textMetrics = ctx.measureText(text);
    const padding = 6;
    const w = textMetrics.width + padding * 2;
    const h = 24;
    const x = p.x - w / 2;
    const y = p.y - 35; // Au-dessus du point

    // Fond de l'infobulle
    ctx.fillStyle = 'rgba(30, 41, 59, 0.95)'; // Slate 800
    ctx.beginPath();
    if (ctx.roundRect) ctx.roundRect(x, y, w, h, 4);
    else ctx.rect(x, y, w, h); // Fallback
    ctx.fill();

    // Petit triangle vers le bas
    ctx.beginPath();
    ctx.moveTo(p.x, y + h + 5);
    ctx.lineTo(p.x - 5, y + h);
    ctx.lineTo(p.x + 5, y + h);
    ctx.fill();

    // Texte
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, p.x, y + h / 2);
    ctx.restore();
  }

  parseAttributes() {
    const a = ['min', 'max', 'step', 'width', 'height', 'labelFrequency'];
    a.forEach(at => { if(this.hasAttribute(at)) this.config[at] = parseFloat(this.getAttribute(at)); });
    if(this.hasAttribute('orientation')) this.config.orientation = this.getAttribute('orientation');
    if(this.hasAttribute('points')) {
        try { this.config.points = JSON.parse(this.getAttribute('points')); }
        catch(e) { this.config.points = []; }
    }
    if(this.hasAttribute('visibleLabels')) {
        try { this.config.visibleLabels = JSON.parse(this.getAttribute('visibleLabels')); }
        catch(e) { this.config.visibleLabels = null; }
    }
  }
}

customElements.define('math974-axe-gradue', AxeGradueComponent);